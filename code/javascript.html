<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="testing.css" media="screen" >
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <title>Document</title>
</head>
<style>
  p{
    font-size: 18px;
  }
</style>
<body>
    
  <div class="container-fluid" style="margin-top:40px; border-top: 1px solid gray">
    <div class="row row-border">
      <div class="col-lg-2 column-border" style="padding-left: 36px">
        method
    </div>
    <div class="col-lg-6 column-border" style="padding-left: 36px;">
      Javascript
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
    description
  </div>
  </div>
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      Change tag using javascript [duplicate]<br>
      Replace particular html tags using javascript
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    <textarea class="textarea-size">var s=<div>hello world<br/><li>First LI</li><li>Second LI</li></div></p>"; <br>  
      s = s.replace(/<li>/g, "#");<br>  
      s = s.replace(/<\/li>/g,"<br/>"); <br> 
      alert(s);<br></textarea >
    
  
  var e = document.getElementsByTagName('span')[0]; <br>
  var d = document.createElement('div'); <br>
  d.innerHTML = e.innerHTML; <br>
  e.parentNode.replaceChild(d, e); <br>
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  replace one html with another
  </div>
  </div>
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      jquery for beginners
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    https://www.cs.utexas.edu/~teammco/teaching/fall2013_cs329e/jQuery/jquery_presentation.pdf
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  
  </div>
  </div>
  
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      jquery keydown
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    var keyCode = (event.keyCode ? event.keyCode : event.which);
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  
  </div>
  </div>
  <h2>classList add remove toggle</h2>
        <b>document.getElementById("myDIV").classList.add("mystyle");</b> <br>
        <b>document.getElementById("myDIV").classList.add("mystyle", "anotherClass", "thirdClass");</b> <br>
        <b>document.getElementById("myDIV").classList.remove("mystyle");</b> <br>
        <b>document.getElementById("myDIV").classList.remove("mystyle", "anotherClass", "thirdClass");</b> <br>
        <b>document.getElementById("myDIV").classList.toggle("newClassName");</b>
  <div class="container">
    <h1>Javascript Info</h1>

    <h4>symbol</h4>
    <a href="https://www.youtube.com/watch?v=DHrYasp1OTw&ab_channel=ColtSteele">FINALLY - ES6 Symbols are Explained!</a>

    <h4>typeof</h4>
    <img src="images/typeof_table.png" width="600" height="400"><br>    
    <h4> use strict</h4>
    <h4>Nullish coalescing operator</h4>
    '??' - a ?? b  expands to  a !== null && a !== undefined ? a : b <br>
Transpilers - A transpiler is a special piece of software that can parse (“read and understand”) modern code,
and rewrite it using older syntax constructs, so that the result would be the same. <br>

E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100. <br>

<h4>transpiler</h4>
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100. <br>

Babel is one of the most prominent transpilers <br>

Modern project build systems, such as webpack, provide means to run transpiler automatically on every code change, so it’s very easy to integrate into development process. <br>

<h4>Polyfills</h4>
Polyfills - In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail. <br>
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations. <br>

Two interesting libraries of polyfills are: <br>

core js that supports a lot, allows to include only needed features. <br>
polyfill.io service that provides a script with polyfills, depending on the features and user’s browser. <br>

<h4>Objects</h4>
<a href="https://www.google.co.in/books/edition/Object_Oriented_JavaScript/s08oDwAAQBAJ?hl=en&gbpv=1&dq=javascript+object+value+writable+enumeration+configurable&pg=PA135&printsec=frontcover">Object Oriented Javascript</a> <br>
<a href="https://mathiasbynens.be/notes/shapes-ics">JavaScript’s object model</a> <br>
<b>property attribute</b> 
Other than the <b>[[Value]]</b>  itself, the spec defines these properties: <br>
<b>[[Writable]]</b>  which determines whether the property can be reassigned to, <br>
<b>[[Enumerable]]</b>  which determines whether the property shows up in for-in loops, <br>
and <b>[[Configurable]]</b>  which determines whether the property can be deleted. <br>
<a href="https://www.youtube.com/watch?v=HZjvoftRvGE">Iterable vs Enumerable in JavaScript</a> <br>
<a href="https://medium.com/better-programming/different-ways-to-duplicate-objects-in-javascript-c199be34ecb7">Different Ways to Duplicate Objects in JavaScript</a> <br>
<h4>primitive data</h4>
<img src="images/primitive.png" width="400" height="400"><br>
<h4>object</h4>
<img src="images/object.png" width="400" height="400"><br>
<h4>shallow copy deep copy</h4>
<img src="images/shallowcopy_deepcopy.png" width="400" height="400"><br>
Usually, the figure brackets {...} are used. That declaration is called an <b>object literal</b>. <br>

<b>multiword property names</b> <br>
let user = {<br>
  name: "John",<br>
  age: 30,<br>
  <b>"likes birds"</b>: true  <b>// multiword property name must be quoted</b> <br>
}; <br>

<b>“trailing” or “hanging” comma</b> <br>

let user = { <br>
  name: "John", <br>
  age: 30,<br>
}<br>

<b>Square brackets</b> <br>
let user = {}; <br>
// set <br>
user["likes birds"] = true; <br>

Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows: <br>
let key = "likes birds"; <br>

// same as user["likes birds"] = true; <br>
user[key] = true; <br>

the variable <b>key</b> may be calculated at run-time or depend on the user input <br>
let key = prompt("What do you want to know about the user?", "name"); <br>

// access by variable <br>
alert( user[key] ); // John (if enter "name") <br>
<b>Computed properties</b> <br>
let fruit = prompt("Which fruit to buy?", "apple");<br>

let bag = {<br>
  [fruit]: 5, // the name of the property is taken from the variable fruit<br>
};<br>

alert( bag.apple ); // 5 if fruit="apple"<br>
<b>Property value shorthand</b> <br>
function makeUser(name, age) { <br>
  return { <br>
    name: name,<br>
    age: age,<br>
    // ...other properties<br>
  };<br>
}

let user = makeUser("John", 30);<br>
alert(user.name); // John<br>
<b>Instead of name:name we can just write name, like this:</b> <br>
function makeUser(name, age) { <br>
  return {<br>
    name, // same as name: name<br>
    age,  // same as age: age<br>
    // ...<br>
  };<br>
  <b>Property existence test, “in” operator</b> <br>
  <b>"key" in object</b> <br>
  let user = { name: "John", age: 30 }; <br>

alert( "age" in user ); // true, user.age exists<br>
alert( "blabla" in user ); // false, user.blabla doesn't exist<br>

<b>Why does the in operator exist? Isn’t it enough to compare against undefined?</b>  <br> 

Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.<br>

It’s when an object property exists, but stores undefined:<br>

let obj = {<br>
  test: undefined<br>
};<br>

alert( obj.test ); // it's undefined, so - no such property?<br>

alert( "test" in obj ); // true, the property does exist!<br>

}<br>

<b>The “for…in” loop</b> <br>
let user = { <br>
  name: "John",<br>
  age: 30,<br>
  isAdmin: true<br>
};<br>

for (let key in user) {<br>
  // keys<br>
  alert( key );  // name, age, isAdmin<br>
  // values for the keys<br>
  alert( user[key] ); // John, 30, true<br>
}<br>

<b>Ordered like an object</b> <br>
let codes = { <br>
  "49": "Germany",<br>
  "41": "Switzerland",<br>
  "44": "Great Britain",<br>
  // ..,<br>
  "1": "USA"<br>
};<br>

for (let code in codes) {<br>
  alert(code); // 1, 41, 44, 49<br>
}<br>


<h4>Object references and copying</h4>
<b>A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.</b> <br>
let user = { name: "John" }; <br>

let admin = user; // copy the reference <br>
let user = { name: 'John' }; <br>

let admin = user;<br>

admin.name = 'Pete'; // changed by the "admin" reference<br>

alert(user.name); // 'Pete', changes are seen from the "user" reference<br>
<b>Comparison by reference</b> <br>
let a = {}; <br>
let b = a; // copy the reference<br>

alert( a == b ); // true, both variables reference the same object<br>
alert( a === b ); // true <br>
<b>two independent objects </b> <br>
let a = {}; <br>
let b = {}; // two independent objects<br>

alert( a == b ); // false<br>

<b>Cloning and merging, Object.assign</b> <br>
let user = { <br>
  name: "John", <br>
  age: 30<br>
};<br>

let clone = {}; // the new empty object<br>

// let's copy all user properties into it<br>
for (let key in user) {<br>
  clone[key] = user[key];<br>
}<br>

// now clone is a fully independent object with the same content<br>
clone.name = "Pete"; // changed the data in it<br>

alert( user.name ); // still John in the original object<br>
<b>Object.assign(dest, [src1, src2, src3...]) - copy paste content</b> <br>
<p><i>Objects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself. <br>

  All operations via copied references (like adding/removing properties) are performed on the same single object.<br>
  
  To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function, such as _.cloneDeep(obj).<br></i></p> 
let user = { name: "John" }; <br>

let permissions1 = { canView: true };<br>
let permissions2 = { canEdit: true };<br>

// copies all properties from permissions1 and permissions2 into user<br>
Object.assign(user, permissions1, permissions2);<br>

// now user = { name: "John", canView: true, canEdit: true }<br>
<b>If the copied property name already exists, it gets overwritten:</b> <br>
<b>Nested cloning</b> <br>
Until now we assumed that all properties of user are primitive. But properties can be references to other objects. What to do with them? <br>
let user = { <br>
  name: "John",<br>
  sizes: {<br>
    height: 182,<br>
    width: 50<br>
  }<br>
};<br>

let clone = Object.assign({}, user);<br>

alert( user.sizes === clone.sizes ); // true, same object <b>sizes object is not copied.  It is nested object</b> <br>

// user and clone share sizes<br>
user.sizes.width++;       // change a property from one place<br>
alert(clone.sizes.width); // 51, see the result from the other one<br>

<h4>Object to primitive conversion</h4>
<a href="https://www.youtube.com/watch?v=kNYH9oU9dDw&ab_channel=9StarStudio">Modern Javascript Objects 5 Object to primitive conversion</a>
What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)? <br>
<b>when addition and substraction is used on objects it is converted to number</b> <br>
<b>In that case, objects are auto-converted to primitives, and then the operation is carried out.</b> <br>
In the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it. <br>
 <b>All objects are true in a boolean context.</b> There are only numeric and string conversions. <br>
<b>The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.</b> <br>
As for the string conversion – it usually happens when we output an object like alert(obj) and in similar contexts. <b>obj will be converted to string as alert takes string</b> <br>
  </div>

<a href="https://stackoverflow.com/questions/4750225/what-does-object-object-mean">object to primitive conversion</a>

<h4>Module</h4>
<a href="https://www.youtube.com/watch?v=cRHQNNcYf6s&ab_channel=WebDevSimplified">JavaScript ES6 Modules</a>
 
<h4>15 JavaScript concepts that every JavaScript Programmer must know</h4>
<ol>
  <li>JavaScript Prototype</li>
  <li> JavaScript(ES6) Class</li>
  <li>IIFE</li>
  <li>understanding Scope</li>
  <li>JavaScript Closures</li>
  <li>The Module Pattern</li>
  <li>Hoisting</li>
  <li>Currying</li>
  <li>Memoization</li>
  <li>The apply, call, and bind methods</li>
  <li>Polymorphism in JavaScript</li>
  <li>Asynchronous Js </li>
  <li>Callback Function</li>
  <li>Understand Promises</li>
  <li>Async & Await</li>
</ol>

<h4>Execution context</h4>
<a href="https://levelup.gitconnected.com/learn-javascript-fundamentals-scope-context-execution-context-9fe8673b3164">Understanding JavaScript Execution Context and How It Relates to Scope and the `this` Context</a>
<a href="https://www.youtube.com/watch?v=_QXn0tW2gSY">Execution Context and Execution Stack in JavaScript in Hindi | Advanced JavaScript</a> <br>
<a href="https://www.youtube.com/watch?v=HDCi0royjkM">Call Stack & Execution Context Explained With Live Example | Advanced JavaScript</a> <br>
<a href="https://www.youtube.com/watch?v=9DDS5aXx9y8">Hoisting in JavaScript in Hindi | Function Hoisting in JavaScript</a><br>
<a href="http://dannyzhang.run/2017/04/03/How-JavaScript-works-Behind-the-Scenes/">How JavaScript Works Behind the Scenes</a>

<h4>Javascript Memory model</h4>
<a href="https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239">JavaScript’s Memory Model</a>
<h2>let myNumber = 23</h2> 
<img src="images/variable_assignment.jpeg" width="500" height="200">
<h2>let newVar = myNumber</h2> 
<img src="images/variable_assigned_to_variable.jpeg" width="500" height="200">
<h2>myNumber = myNumber + 1</h2>
<p><b>primitive data</b> types in JS are <b>immutable</b> , when “myNumber + 1” resolves to “24”, JS will allocate a new address in memory, store 24 as its value, and “myNumber” will point to the new address.</p>
<img src="images/variable_memory_allocation.jpeg" width="500" height="200">
  <h2>call stack and the heap</h2>
  <p>The <b>call stack</b> is where <b>primitives are stored</b>  (in addition to function calls). A rough representation of the call stack after declaring the variables in the previous section is below.</p>
  <p>The <b>heap</b> is where <b>non-primitives are stored</b>. The key difference is that the heap can store unordered data that can grow dynamically—perfect for arrays and objects.</p>
<h2>let myArray = []</h2>
<img src="images/callstack_heap.jpeg" width="500" height="200">


<h4>Lexical scope - closure</h4>
<!-- <img src="images/Closure.png" width="600" height="200"> <br> -->
<img src="images/Closure.png" width="600" height="200"> <br> <br>
<img src="images/Closure2.png" width="600" height="300">
<h4>Higher order function</h4>


<h4>Object Oriented Javascript</h4>
<h2>Hashes and associative arrays</h2> 
<p>In some programming languages, there is a distinction between:</p> 
<p>A regular array, also called an <b>indexed or enumerated</b> array (the keys are
  numbers)</p> 
<p>An associative array, also called a <b>hash or a dictionary</b> (the keys are strings)</p> 
<p>JavaScript uses arrays to represent indexed arrays and objects to represent associative
  arrays. If you want a hash in JavaScript, you use an object.</p> 

  <h2>Accessing an object's properties</h2> 
<p>There are two ways to access the property of an object:</p>
<p>Using the square bracket notation, for example, <b>hero['occupation']</b> </p>
<p>Using the dot notation, for example, <b>hero.occupation</b> </p> 
 
<h2>Calling an object's methods</h2>  
<p> hero.say('a', 'b', 'c');</p>
<p>hero['say']();</p>

<h2>Deleting a property:</h2> 
 <p>delete hero.name;</p> 

 <h4>Constructor functions</h4>
 function Hero() { <br>
  this.occupation = 'Ninja'; <br>
  } <br> <br>

  function Hero(name) { <br>
    this.name = name; <br>
    this.occupation = 'Ninja'; <br>
    this.whoAreYou = function () { <br>
    return "I'm " + <br>
    this.name + <br>
    " and I'm a " + <br>
    this.occupation; <br>
    };<br>
    } <br> <br>

    <p> <b>If you call a function that is designed to be a constructor but you omit the new operator, it is
      not an error. However, it doesn't give you the expected result:</b> </p> 
 > var h = Hero('Leonardo'); <br>
 > typeof h; <br>
 "undefined" <br>
What happened here? There is no new operator, so a new object was not created. The <br>
function was called like any other function, so the variable h contains the value that the <br>
function returns. The function does not return anything (there's no return function), so it <br>
actually returns undefined, which gets assigned to the variable h. <br>
In this case, what does this refer to? It refers to the global object. <br>
  
<h4>The constructor property</h4> 
When an object is created, a special property is assigned to it behind the scenes–the <br>
constructor property. It contains a reference to the constructor function used to create <br>
this object. <br>
Objects <br>
Continuing from the previous example: <br>
 > <b> h2.constructor; <br>
  function Hero(name) { <br>
  this.name = name; <br>
  }</b> <br>
As the constructor property contains a reference to a function, you might as well call this <br>
function to produce a new object. The following code is like saying, “I don't care how object <br>
h2 was created, but I want another one just like it”: <br>
 > var h3 = new h2.constructor('Rafaello'); <br>
 > h3.name; <br> 
 "Rafaello" <br>
If an object was created using the object literal notation, its constructor is the built-in <br>
Object() constructor function (there is more about this later in this chapter): <br>
 > var o = {}; <br>
 ><b>o.constructor; <br>
  function Object() { [native code] } <br>
  > typeof o.constructor; <br>
  "function"</b>  <br> <br>

  <h4>The instanceof operator</h4> 
With the instanceof operator, you can test whether an object was created with a specific <br>
constructor function: <br>
 > <b> function Hero() {} <br>
  > var h = new Hero(); <br>
  > var o = {};</b> <br>
 > <b>h instanceof Hero;</b>  <br>
 true <br>
 > <b>h instanceof Object;</b>  <br>
 true <br>
 > o instanceof Object; <br>
 true <br>
<b> Note that you don't put parentheses after the function name (you don't use h instanceof <br>
  Hero()).</b> This is because you're not invoking this function, but just referring to it by name, <br>
as with any other variable. <br> <br>

If you think about how objects are created inside constructor functions, you can imagine <br>
that a <b>variable called this is defined at the top of the function</b>  and then returned at the end. <br>
Consider the following code:  <br>
 function C() { <br>
 // <b>var this = {}; </b> // pseudo code, you can't do this <br>
 this.a = 1; <br>
 // <b>return this;</b>  <br>
 } <br> <br>

 <p>‘this’ is actually a binding that is made when a function is invoked, not when it is declared. What ‘this’ references is determined entirely by the call-site where the function is called.</p>
 <h2>method inside object</h2>
 <b>(Lingo explainer for JavaScript n00bs:  “method” is the name for a function contained within an object. “Callbacks” are anonymous functions passed as an argument into another function. Both are still ultimately just functions, though).</b> <br> <br>

 <h2>Inferring object types</h2>
 <b>typeof returns an object when used with arrays.</b> 
 > <b>Object.prototype.toString.call({});</b> 
 "[object Object]"
 > <b>Object.prototype.toString.call([]);</b> 
 "[object Array]"
 <h2>The language has 4 function invocation types:</h2> 
 <a href="https://dmitripavlutin.com/gentle-explanation-of-this-in-javascript/">Gentle Explanation of "this" in JavaScript</a> <br> <br>
 In JavaScript the situation is different: this is the context of a function invocation (a.k.a. exection). <br> 
<b>function invocation:</b>  alert('Hello World!') <br>
<b>method invocation:</b>  console.log('Hello World!') <br>
<b>constructor invocation:</b>  new RegExp('\\d') <br>
<b>indirect invocation:</b>  alert.call(undefined, 'Hello World!') <br>
Each invocation type defines the context in its way, so this behaves differently than the developer expects. <br> <br>

const numbers = { <br>
  numberA: 5,<br>
  numberB: 10,<br>

  sum: function() {<br>
    console.log(this === numbers); // => true <br>

    function calculate() { <br>
      // this is window or undefined in strict mode <br>
      console.log(this === numbers); // => false  <br>
      return this.numberA + this.numberB; <br>
    } <br>

    return calculate(); <br>
  } <br>
}; <br>

numbers.sum(); // => NaN or throws TypeError in strict mode <br>
<b>numbers.sum() is a method invocation on an object</b>  (see 3.) thus this equals number. <br>
<b>calculate() function is defined inside sum()</b> , so you might expect to have this as numbers object in when invoking calculate() too. <br>
<b>calculate() is a function invocation</b>  (but not method invocation), <b>thus here this is the global object window</b>  (case 2.1.) or undefined in strict mode (case 2.2.). Even if the outer function numbers.sum() has the context as numbers object, it doesn’t have influence here. <br>

<b>return calculate.call(this);</b> can be used. <br> <br>
<b>another solution is arrow function</b>  <br>
const calculate = () => { <br>
  console.log(this === numbers); // => true <br>
  return this.numberA + this.numberB; <br>
} <br>

return calculate(); <br>
 <b>The arrow function resolves this lexically, or, in other words, uses this value of numbers.sum() method.</b>
  <h2>Arrow function</h2>
  <b>Arrow functions are always anonymous.</b> <br>
<b>Arrow functions do not have their own value of this. The value of this in an arrow function is inherited from the enclosing (lexical) scope.</b> <br>
<b>A lexical scope is a scope that surrounds the function scope, and the dynamic scope is the scope that called the function (usually an object)</b> <br>
 <b>No parameters: () => {...}</b>  <br>
 <b>One parameter: a => {...}</b>  <br>
 <b>More than one parameters: (a,b) => {...}</b>  <br>

 Arrow functions can have both the statement block bodies as well as expression bodies: <br>
 <b>n => { return n+n}</b>  //statement block <br>
 <b>n =>n+n</b>  //expression <br>
Both are equivalent but the second variation is concise and preferred. <br> 
  </div>

  <h4>callback, promise, asyn, await</h4>
  <b>callback function:</b>It helps us develop asynchronous JavaScript code and keeps us safe from problems and errors. <br>
    In JavaScript, the way to create a callback function is to pass it as a parameter to another function, and then to call it back <br>
    right after something has happened or some task is completed. <br>
  <a href="https://www.youtube.com/watch?v=PoRJizFvM7s">Async JS Crash Course - Callbacks, Promises, Async Await</a> <br>

  <b>promises:</b>A Promise is a special JavaScript object. It produces a value after an asynchronous (aka, async) <br>  
  operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on. <br>

  <b>Successful call completions are indicated by the resolve function call, and errors are indicated by the reject function call.</b>  <br>
  You can create a promise using the promise constructor like this: <br>
  <b>let promise = new Promise(function(resolve, reject) {    <br>
    // Make an asynchronous call and either resolve or reject <br>
});</b> <br>
<a href="https://www.freecodecamp.org/news/javascript-promise-tutorial-how-to-resolve-or-reject-promises-in-js/">JavaScript Promise Tutorial – How to Resolve or Reject Promises in JS</a> <br>

<b>A Promise executor should call only one resolve or one reject. Once <br>
  one state is changed (pending => fulfilled or pending => rejected), <br>
  that's all. Any further calls to resolve or reject will be ignored.</b> <br>


  <h4>functional programming</h4>
  <a href="file:///C:/Users/USER/Downloads/functional-programing-with-js-cheatsheet---progress-whitepaper.pdf">Functional Programming
    with JavaScript (ES6)</a>

  <script type="text/javascript" src="testing.js"></script>
</body>
</html>