<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="testing.css" media="screen" >
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <title>Document</title>
</head>
<body>
    
  <div class="container-fluid" style="margin-top:40px; border-top: 1px solid gray">
    <div class="row row-border">
      <div class="col-lg-2 column-border" style="padding-left: 36px">
        method
    </div>
    <div class="col-lg-6 column-border" style="padding-left: 36px;">
      Javascript
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
    description
  </div>
  </div>
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      Change tag using javascript [duplicate]<br>
      Replace particular html tags using javascript
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    <textarea class="textarea-size">var s=<div>hello world<br/><li>First LI</li><li>Second LI</li></div></p>"; <br>  
      s = s.replace(/<li>/g, "#");<br>  
      s = s.replace(/<\/li>/g,"<br/>"); <br> 
      alert(s);<br></textarea >
    
  
  var e = document.getElementsByTagName('span')[0]; <br>
  var d = document.createElement('div'); <br>
  d.innerHTML = e.innerHTML; <br>
  e.parentNode.replaceChild(d, e); <br>
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  replace one html with another
  </div>
  </div>
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      jquery for beginners
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    https://www.cs.utexas.edu/~teammco/teaching/fall2013_cs329e/jQuery/jquery_presentation.pdf
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  
  </div>
  </div>
  
  
  <div class="row row-border">
    <div class="col-lg-2 column-border" style="padding-left: 36px">
      jquery keydown
  </div>
  <div class="col-lg-6 column-border" style="padding-left: 36px;">
    var keyCode = (event.keyCode ? event.keyCode : event.which);
  </div>
  <div class="col-lg-4" style="padding-left: 36px;">
  
  </div>
  </div>

  <div class="container">
    <h1>Javascript Info</h1>

    <h4>symbol</h4>
    <a href="https://www.youtube.com/watch?v=DHrYasp1OTw&ab_channel=ColtSteele">FINALLY - ES6 Symbols are Explained!</a>

    <h4> use strict</h4>
    <h4>Nullish coalescing operator</h4>
    '??' - a ?? b  expands to  a !== null && a !== undefined ? a : b <br>
Transpilers - A transpiler is a special piece of software that can parse (“read and understand”) modern code,
and rewrite it using older syntax constructs, so that the result would be the same. <br>

E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100. <br>

<h4>transpiler</h4>
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100. <br>

Babel is one of the most prominent transpilers <br>

Modern project build systems, such as webpack, provide means to run transpiler automatically on every code change, so it’s very easy to integrate into development process. <br>

<h4>Polyfills</h4>
Polyfills - In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail. <br>
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations. <br>

Two interesting libraries of polyfills are: <br>

core js that supports a lot, allows to include only needed features. <br>
polyfill.io service that provides a script with polyfills, depending on the features and user’s browser. <br>

<h4>Objects</h4>
<a href="https://mathiasbynens.be/notes/shapes-ics">JavaScript’s object model</a>
<a href="https://medium.com/better-programming/different-ways-to-duplicate-objects-in-javascript-c199be34ecb7">Different Ways to Duplicate Objects in JavaScript</a> <br>
<h4>primitive data</h4>
<img src="images/primitive.png" width="400" height="400"><br>
<h4>object</h4>
<img src="images/object.png" width="400" height="400"><br>
<h4>shallow copy deep copy</h4>
<img src="images/shallowcopy_deepcopy.png" width="400" height="400"><br>
Usually, the figure brackets {...} are used. That declaration is called an <b>object literal</b>. <br>

<b>multiword property names</b> <br>
let user = {<br>
  name: "John",<br>
  age: 30,<br>
  <b>"likes birds"</b>: true  <b>// multiword property name must be quoted</b> <br>
}; <br>

<b>“trailing” or “hanging” comma</b> <br>

let user = { <br>
  name: "John", <br>
  age: 30,<br>
}<br>

<b>Square brackets</b> <br>
let user = {}; <br>
// set <br>
user["likes birds"] = true; <br>

Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows: <br>
let key = "likes birds"; <br>

// same as user["likes birds"] = true; <br>
user[key] = true; <br>

the variable <b>key</b> may be calculated at run-time or depend on the user input <br>
let key = prompt("What do you want to know about the user?", "name"); <br>

// access by variable <br>
alert( user[key] ); // John (if enter "name") <br>
<b>Computed properties</b> <br>
let fruit = prompt("Which fruit to buy?", "apple");<br>

let bag = {<br>
  [fruit]: 5, // the name of the property is taken from the variable fruit<br>
};<br>

alert( bag.apple ); // 5 if fruit="apple"<br>
<b>Property value shorthand</b> <br>
function makeUser(name, age) { <br>
  return { <br>
    name: name,<br>
    age: age,<br>
    // ...other properties<br>
  };<br>
}

let user = makeUser("John", 30);<br>
alert(user.name); // John<br>
<b>Instead of name:name we can just write name, like this:</b> <br>
function makeUser(name, age) { <br>
  return {<br>
    name, // same as name: name<br>
    age,  // same as age: age<br>
    // ...<br>
  };<br>
  <b>Property existence test, “in” operator</b> <br>
  <b>"key" in object</b> <br>
  let user = { name: "John", age: 30 }; <br>

alert( "age" in user ); // true, user.age exists<br>
alert( "blabla" in user ); // false, user.blabla doesn't exist<br>

<b>Why does the in operator exist? Isn’t it enough to compare against undefined?</b>  <br> 

Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.<br>

It’s when an object property exists, but stores undefined:<br>

let obj = {<br>
  test: undefined<br>
};<br>

alert( obj.test ); // it's undefined, so - no such property?<br>

alert( "test" in obj ); // true, the property does exist!<br>

}<br>

<b>The “for…in” loop</b> <br>
let user = { <br>
  name: "John",<br>
  age: 30,<br>
  isAdmin: true<br>
};<br>

for (let key in user) {<br>
  // keys<br>
  alert( key );  // name, age, isAdmin<br>
  // values for the keys<br>
  alert( user[key] ); // John, 30, true<br>
}<br>

<b>Ordered like an object</b> <br>
let codes = { <br>
  "49": "Germany",<br>
  "41": "Switzerland",<br>
  "44": "Great Britain",<br>
  // ..,<br>
  "1": "USA"<br>
};<br>

for (let code in codes) {<br>
  alert(code); // 1, 41, 44, 49<br>
}<br>


<h4>Object references and copying</h4>
<b>A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.</b> <br>
let user = { name: "John" }; <br>

let admin = user; // copy the reference <br>
let user = { name: 'John' }; <br>

let admin = user;<br>

admin.name = 'Pete'; // changed by the "admin" reference<br>

alert(user.name); // 'Pete', changes are seen from the "user" reference<br>
<b>Comparison by reference</b> <br>
let a = {}; <br>
let b = a; // copy the reference<br>

alert( a == b ); // true, both variables reference the same object<br>
alert( a === b ); // true <br>
<b>two independent objects </b> <br>
let a = {}; <br>
let b = {}; // two independent objects<br>

alert( a == b ); // false<br>

<b>Cloning and merging, Object.assign</b> <br>
let user = { <br>
  name: "John", <br>
  age: 30<br>
};<br>

let clone = {}; // the new empty object<br>

// let's copy all user properties into it<br>
for (let key in user) {<br>
  clone[key] = user[key];<br>
}<br>

// now clone is a fully independent object with the same content<br>
clone.name = "Pete"; // changed the data in it<br>

alert( user.name ); // still John in the original object<br>
<b>Object.assign(dest, [src1, src2, src3...]) - copy paste content</b> <br>
<p><i>Objects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself. <br>

  All operations via copied references (like adding/removing properties) are performed on the same single object.<br>
  
  To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function, such as _.cloneDeep(obj).<br></i></p> 
let user = { name: "John" }; <br>

let permissions1 = { canView: true };<br>
let permissions2 = { canEdit: true };<br>

// copies all properties from permissions1 and permissions2 into user<br>
Object.assign(user, permissions1, permissions2);<br>

// now user = { name: "John", canView: true, canEdit: true }<br>
<b>If the copied property name already exists, it gets overwritten:</b> <br>
<b>Nested cloning</b> <br>
Until now we assumed that all properties of user are primitive. But properties can be references to other objects. What to do with them? <br>
let user = { <br>
  name: "John",<br>
  sizes: {<br>
    height: 182,<br>
    width: 50<br>
  }<br>
};<br>

let clone = Object.assign({}, user);<br>

alert( user.sizes === clone.sizes ); // true, same object <b>sizes object is not copied.  It is nested object</b> <br>

// user and clone share sizes<br>
user.sizes.width++;       // change a property from one place<br>
alert(clone.sizes.width); // 51, see the result from the other one<br>

<h4>Object to primitive conversion</h4>
<a href="https://www.youtube.com/watch?v=kNYH9oU9dDw&ab_channel=9StarStudio">Modern Javascript Objects 5 Object to primitive conversion</a>
What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)? <br>
<b>when addition and substraction is used on objects it is converted to number</b> <br>
<b>In that case, objects are auto-converted to primitives, and then the operation is carried out.</b> <br>
In the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it. <br>
 <b>All objects are true in a boolean context.</b> There are only numeric and string conversions. <br>
<b>The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.</b> <br>
As for the string conversion – it usually happens when we output an object like alert(obj) and in similar contexts. <b>obj will be converted to string as alert takes string</b> <br>
  </div>

<h4>Module</h4>
<a href="https://www.youtube.com/watch?v=cRHQNNcYf6s&ab_channel=WebDevSimplified">JavaScript ES6 Modules</a>
 
<h4>15 JavaScript concepts that every JavaScript Programmer must know</h4>
<ol>
  <li>JavaScript Prototype</li>
  <li> JavaScript(ES6) Class</li>
  <li>IIFE</li>
  <li>understanding Scope</li>
  <li>JavaScript Closures</li>
  <li>The Module Pattern</li>
  <li>Hoisting</li>
  <li>Currying</li>
  <li>Memoization</li>
  <li>The apply, call, and bind methods</li>
  <li>Polymorphism in JavaScript</li>
  <li>Asynchronous Js </li>
  <li>Callback Function</li>
  <li>Understand Promises</li>
  <li>Async & Await</li>
</ol>

<h4>Execution context</h4>
<a href="https://www.youtube.com/watch?v=_QXn0tW2gSY">Execution Context and Execution Stack in JavaScript in Hindi | Advanced JavaScript</a>
<a href="https://www.youtube.com/watch?v=HDCi0royjkM">Call Stack & Execution Context Explained With Live Example | Advanced JavaScript</a>
<a href="https://www.youtube.com/watch?v=9DDS5aXx9y8">Hoisting in JavaScript in Hindi | Function Hoisting in JavaScript</a>

<h4>Lexical scope</h4>

<h4>Higher order function</h4>
  </div>

  <script type="text/javascript" src="testing.js"></script>
</body>
</html>